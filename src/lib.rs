//
// Takes any string and returns something which can be used as a key in S3.
//
pub fn to_s3_key(key: String) -> String {
    let mut encoded = "".to_owned();
    for ch in key.chars() {
        match ch {
            'a'...'z' | 'A'...'Z' | '0'...'9' | '/' | '!' | '-' | '_' | '.' | '*' | '\'' => {
                encoded.push(ch)
            }
            _ => encoded.push_str(&format!("({})", ch as u32)),
        }
    }
    encoded
}

//
// Takes a key generated by to_s3_key and returns the original string.
//
pub fn from_s3_key(source: String) -> Option<String> {
    let mut in_parens = false;
    let mut decoded = "".to_owned();
    let mut char_value: u32 = 0;
    for ch in source.chars() {
        match ch {
            '(' => {
                if in_parens {
                    return None;
                }
                in_parens = true;
                char_value = 0;
            }
            ')' => {
                if !in_parens {
                    return None;
                }
                in_parens = false;
                if let Some(ch) = std::char::from_u32(char_value) {
                    decoded.push(ch);
                } else {
                    return None;
                }
            }
            '0'...'9' => {
                if in_parens {
                    char_value = char_value * 10 + ch as u32 - b'0' as u32;
                } else {
                    decoded.push(ch);
                }
            }
            _ => {
                if in_parens {
                    return None;
                } else {
                    decoded.push(ch)
                }
            }
        }
    }
    if in_parens {
        None
    } else {
        Some(decoded)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn two_way_test(s: &str, t: &str) {
        assert_eq!(to_s3_key(s.to_owned()), t.to_owned());
        assert_eq!(from_s3_key(t.to_owned()).unwrap(), s.to_owned());
    }

    #[test]
    fn simple_string() {
        two_way_test("", "");
        two_way_test("abcd123XYZ", "abcd123XYZ");
        two_way_test("/!-_.*'", "/!-_.*'");
    }

    #[test]
    fn complex_string() {
        two_way_test(
            "More {complex} <string>:\\@#$%^&*()=+;?",
            "More(32)(123)complex(125)(32)(60)string(62)(58)(92)(64)(35)(36)(37)(94)(38)*(40)(41)(61)(43)(59)(63)"
        );
    }

    #[test]
    fn realistic_s3_key() {
        two_way_test(
            "/DATA/section/document/file-0001.pdf",
            "/DATA/section/document/file-0001.pdf",
        );
    }

    #[test]
    fn windows_path() {
        two_way_test(
            "c:\\path to\\file\\filename.ext",
            "c(58)(92)path(32)to(92)file(92)filename.ext",
        );
    }

    #[test]
    fn invalid_chars() {
        assert_eq!(from_s3_key("(1x2)".to_owned()), None);
        assert_eq!(from_s3_key("(123".to_owned()), None);
        assert_eq!(from_s3_key("123)".to_owned()), None);
        assert_eq!(from_s3_key("((123)".to_owned()), None);
        assert_eq!(from_s3_key("(9999999)".to_owned()), None);
    }
}
